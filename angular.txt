#########################
 angular with typescript
#########################
Why Angular?

✅ 1. Complete Framework
Angular is a full-fledged framework, not just a library. It provides everything you need to build large-scale, enterprise-grade applications:

Routing

HTTP client

Form handling

State management

Dependency injection

Testing utilities

✅ 2. Two-Way Data Binding
Angular offers two-way data binding, meaning the UI reflects model changes instantly and vice versa. This simplifies synchronization between your data and view.

✅ 3. TypeScript-Based
Angular is built on TypeScript, a superset of JavaScript that provides:

Static typing

Better tooling (auto-complete, refactoring)

Catching errors during development

✅ 4. Component-Based Architecture
Angular uses a component-driven structure:

Encourages modular code

Easy to test, reuse, and maintain

Great for team collaboration

✅ 5. CLI Support
The Angular CLI is powerful:

Generates components, services, routes, etc.

Handles builds, testing, and deployment

Reduces setup time significantly

✅ 6. Enterprise-Ready
Angular is used by Google and other major companies, especially for large-scale, maintainable applications. It's highly suitable for long-term, enterprise-level development.

✅ 7. Built-in Features
You get built-in support for:

HTTP communication

Forms (template-driven & reactive)

Routing and guards

Lazy loading for better performance

✅ 8. Large Ecosystem & Community
Angular has a large developer community and ecosystem:

Tons of libraries and tools

Angular Material for UI components

Lots of tutorials, StackOverflow help, and corporate support

🧑‍💼 When to Choose Angular
Use Angular when:

You're building a large, complex SPA (Single Page Application)

You need strong typing and scalability

You're working with teams and long-term projects

You want out-of-the-box solutions (instead of piecing together libraries like with React)
===================================================================================

In Angular, data binding is the way of connecting your TypeScript/Component class data with the HTML template.
There are two major binding types: One-way and Two-way.

🔹 One-Way Data Binding

👉 Data flows in one direction only: from Component (TS class) → View (HTML).

Types of one-way binding in Angular:

Interpolation ({{ }})

<h1>{{ title }}</h1>


Displays component property in the view.

Property Binding ([ ])

<img [src]="imageUrl">


Binds element/property/attribute to component property.

Event Binding (( ))

<button (click)="onClick()">Click</button>


Sends data from View → Component (but not back).

📌 Key point: View updates only when component changes (not vice versa).

🔹 Two-Way Data Binding

👉 Data flows in both directions:

Component → View

View → Component

Example using [(ngModel)]:
<input [(ngModel)]="username" placeholder="Enter name">
<p>Hello, {{ username }}</p>


If username changes in component → input updates.

If input changes in view → component’s username updates.

⚡ Requires FormsModule (for ngModel) in app.module.ts.

✅ Comparison
Feature	One-Way Binding	Two-Way Binding
Direction	Component → View (or View → Component via events)	Component ↔ View
Syntax	{{}}, [ ], ( )	[( )] (banana in a box)
Use case	Displaying static data, handling events	Form fields, editable inputs
Performance	Faster (less checks needed)	Slightly heavier (continuous sync)

👉 In real projects:

Use one-way binding where possible (better performance, clearer flow).

Use two-way binding mostly in forms and input controls.
-------------------------------------------------------------------------------------------


In Angular, directives are special instructions in the DOM (HTML) that tell Angular to change the behavior or appearance of elements.
They are one of Angular’s core features.

🔹 Types of Directives in Angular
1. Component Directives

Technically, every component in Angular is a directive with a template.

Example:

@Component({
  selector: 'app-hello',
  template: `<h1>Hello Angular!</h1>`
})
export class HelloComponent {}


Usage:

<app-hello></app-hello>

2. Structural Directives

👉 These change the DOM structure (add/remove elements).
They are prefixed with *.

*ngIf → conditionally render elements.

<p *ngIf="isLoggedIn">Welcome, User!</p>


*ngFor → loop through a list.

<ul>
  <li *ngFor="let item of items">{{ item }}</li>
</ul>


*ngSwitch → multiple conditional rendering.

<div [ngSwitch]="role">
  <p *ngSwitchCase="'admin'">Admin Panel</p>
  <p *ngSwitchCase="'user'">User Dashboard</p>
  <p *ngSwitchDefault>Guest</p>
</div>

3. Attribute Directives

👉 These change the look or behavior of an existing element/component.

Built-in Examples:

ngClass → dynamically set CSS classes.

<p [ngClass]="{ active: isActive }">Text with class</p>


ngStyle → dynamically set inline styles.

<p [ngStyle]="{ color: isActive ? 'green' : 'red' }">Styled text</p>


Custom Attribute Directive Example:

import { Directive, ElementRef, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef, renderer: Renderer2) {
    renderer.setStyle(el.nativeElement, 'backgroundColor', 'yellow');
  }
}


Usage:

<p appHighlight>Highlighted Text</p>

✅ Summary
Directive Type	Purpose	Example
Component	Defines a reusable UI block	<app-header></app-header>
Structural	Adds/removes DOM elements	*ngIf, *ngFor
Attribute	Changes look/behavior of elements	[ngClass], [ngStyle]

-----------------------------------------------------------------------------------

🔹 What is <ng-template>?

It’s an Angular template element that isn’t rendered directly in the DOM until Angular explicitly tells it to.

Angular uses it for structural directives like *ngIf, *ngFor, ngSwitch, etc.

It acts like a placeholder for content that can be shown conditionally or reused.

🔹 Example 1: Basic ng-template with *ngIf
<h2 *ngIf="isLoggedIn; else guestBlock">
  Welcome User!
</h2>

<ng-template #guestBlock>
  <h2>Please log in</h2>
</ng-template>


👉 Here:

If isLoggedIn is true → "Welcome User!" is displayed.

If false → Angular renders the <ng-template> content (guestBlock).

🔹 Example 2: Multiple else if using ng-template
<h2 *ngIf="role === 'admin'; else managerBlock">Welcome Admin</h2>

<ng-template #managerBlock>
  <h2 *ngIf="role === 'manager'; else guestBlock">Welcome Manager</h2>
</ng-template>

<ng-template #guestBlock>
  <h2>Welcome Guest</h2>
</ng-template>

🔹 Example 3: ngTemplateOutlet (Reusing Templates)
<ng-template #messageTemplate let-name="userName">
  <p>Hello, {{ name }}!</p>
</ng-template>

<!-- Reuse the same template -->
<ng-container *ngTemplateOutlet="messageTemplate; context:{ userName: 'Alice' }"></ng-container>
<ng-container *ngTemplateOutlet="messageTemplate; context:{ userName: 'Bob' }"></ng-container>


👉 Output:

Hello, Alice!
Hello, Bob!

🔹 Why ng-template?

Before Angular v17’s new @if/@for syntax, it was the only way to handle else conditions and template reuse.

Even now, it’s still useful when:

You want reusable UI blocks.

You want to pass template references into child components.


---------------------------------------------------------------------------------------------------------

1. Structural Directives

Definition: They change the structure of the DOM (add, remove, or replace elements).

Identifiable by: They usually start with a * in templates.

Examples:

*ngIf → adds/removes element based on condition

*ngFor → repeats an element for each item in a list

*ngSwitchCase → conditionally displays templates

👉 They manipulate the DOM layout itself.

Example:

<div *ngIf="isLoggedIn">Welcome, User!</div>


If isLoggedIn = false, this <div> won’t even exist in the DOM.

2. Attribute Directives

Definition: They change the appearance or behavior of an existing element, component, or directive without altering the DOM structure.

Examples:

ngClass → add/remove CSS classes

ngStyle → apply inline styles dynamically

Custom attribute directives (like [appHighlight])

👉 They modify the look/behavior of an element.

Example:

<p [ngStyle]="{color: isError ? 'red' : 'green'}">
  Status Message
</p>


Here <p> always exists, only its style changes.

🔑 Key Difference
Feature	Structural Directive 🏗	Attribute Directive 🎨
Effect	Alters DOM structure (add/remove elements)	Alters appearance/behavior of element
Template Syntax	Uses * (e.g., *ngIf)	Uses [] or normal attribute syntax
Examples	*ngIf, *ngFor, *ngSwitch	ngClass, ngStyle, custom highlight

👉 So, think like this:

Structural = Building blocks of DOM (existence of elements)

Attribute = Decorating existing DOM elements
------------------------------------------------------------------------------------------

1. Parent → Child Communication

The Parent passes data to the Child using @Input().

Example:

Parent component template (app.component.html):

<app-child [childData]="parentMessage"></app-child>


Parent component class (app.component.ts):

parentMessage = "Hello from Parent!";


Child component (child.component.ts):

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ childData }}</p>`
})
export class ChildComponent {
  @Input() childData!: string;
}


✔ Here, the parent passes parentMessage to the child.

2. Child → Parent Communication

The Child sends data back to the Parent using @Output() + EventEmitter.

Example:

Child component (child.component.ts):

import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<button (click)="sendData()">Send to Parent</button>`
})
export class ChildComponent {
  @Output() childEvent = new EventEmitter<string>();

  sendData() {
    this.childEvent.emit("Hello Parent! from Child");
  }
}


Parent template (app.component.html):

<app-child (childEvent)="receiveData($event)"></app-child>
<p>{{ messageFromChild }}</p>


Parent class (app.component.ts):

messageFromChild = "";

receiveData(data: string) {
  this.messageFromChild = data;
}


✔ The child emits data, and the parent catches it.

3. Sibling → Sibling Communication

Siblings cannot directly communicate (since they are at the same level).
We use a shared service with RxJS Subject/BehaviorSubject to share data.

Example:

Shared service (data.service.ts):

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class DataService {
  private messageSource = new BehaviorSubject<string>("Default Message");
  currentMessage = this.messageSource.asObservable();

  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}


Sibling 1 (sibling1.component.ts):

import { Component } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-sibling1',
  template: `<button (click)="newMessage()">Send to Sibling2</button>`
})
export class Sibling1Component {
  constructor(private dataService: DataService) {}

  newMessage() {
    this.dataService.changeMessage("Hello from Sibling 1!");
  }
}


Sibling 2 (sibling2.component.ts):

import { Component, OnInit } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-sibling2',
  template: `<p>{{message}}</p>`
})
export class Sibling2Component implements OnInit {
  message!: string;

  constructor(private dataService: DataService) {}

  ngOnInit() {
    this.dataService.currentMessage.subscribe(msg => this.message = msg);
  }
}


✔ Now, Sibling1 → Service → Sibling2 communication works.

🔑 Summary

Parent → Child → @Input()

Child → Parent → @Output() + EventEmitter

Sibling → Sibling → Shared service with RxJS
