#########################
 angular with typescript
#########################
Why Angular?

âœ… 1. Complete Framework
Angular is a full-fledged framework, not just a library. It provides everything you need to build large-scale, enterprise-grade applications:

Routing

HTTP client

Form handling

State management

Dependency injection

Testing utilities

âœ… 2. Two-Way Data Binding
Angular offers two-way data binding, meaning the UI reflects model changes instantly and vice versa. This simplifies synchronization between your data and view.

âœ… 3. TypeScript-Based
Angular is built on TypeScript, a superset of JavaScript that provides:

Static typing

Better tooling (auto-complete, refactoring)

Catching errors during development

âœ… 4. Component-Based Architecture
Angular uses a component-driven structure:

Encourages modular code

Easy to test, reuse, and maintain

Great for team collaboration

âœ… 5. CLI Support
The Angular CLI is powerful:

Generates components, services, routes, etc.

Handles builds, testing, and deployment

Reduces setup time significantly

âœ… 6. Enterprise-Ready
Angular is used by Google and other major companies, especially for large-scale, maintainable applications. It's highly suitable for long-term, enterprise-level development.

âœ… 7. Built-in Features
You get built-in support for:

HTTP communication

Forms (template-driven & reactive)

Routing and guards

Lazy loading for better performance

âœ… 8. Large Ecosystem & Community
Angular has a large developer community and ecosystem:

Tons of libraries and tools

Angular Material for UI components

Lots of tutorials, StackOverflow help, and corporate support

ğŸ§‘â€ğŸ’¼ When to Choose Angular
Use Angular when:

You're building a large, complex SPA (Single Page Application)

You need strong typing and scalability

You're working with teams and long-term projects

You want out-of-the-box solutions (instead of piecing together libraries like with React)
===================================================================================

In Angular, data binding is the way of connecting your TypeScript/Component class data with the HTML template.
There are two major binding types: One-way and Two-way.

ğŸ”¹ One-Way Data Binding

ğŸ‘‰ Data flows in one direction only: from Component (TS class) â†’ View (HTML).

Types of one-way binding in Angular:

Interpolation ({{ }})

<h1>{{ title }}</h1>


Displays component property in the view.

Property Binding ([ ])

<img [src]="imageUrl">


Binds element/property/attribute to component property.

Event Binding (( ))

<button (click)="onClick()">Click</button>


Sends data from View â†’ Component (but not back).

ğŸ“Œ Key point: View updates only when component changes (not vice versa).

ğŸ”¹ Two-Way Data Binding

ğŸ‘‰ Data flows in both directions:

Component â†’ View

View â†’ Component

Example using [(ngModel)]:
<input [(ngModel)]="username" placeholder="Enter name">
<p>Hello, {{ username }}</p>


If username changes in component â†’ input updates.

If input changes in view â†’ componentâ€™s username updates.

âš¡ Requires FormsModule (for ngModel) in app.module.ts.

âœ… Comparison
Feature	One-Way Binding	Two-Way Binding
Direction	Component â†’ View (or View â†’ Component via events)	Component â†” View
Syntax	{{}}, [ ], ( )	[( )] (banana in a box)
Use case	Displaying static data, handling events	Form fields, editable inputs
Performance	Faster (less checks needed)	Slightly heavier (continuous sync)

ğŸ‘‰ In real projects:

Use one-way binding where possible (better performance, clearer flow).

Use two-way binding mostly in forms and input controls.
-------------------------------------------------------------------------------------------


In Angular, directives are special instructions in the DOM (HTML) that tell Angular to change the behavior or appearance of elements.
They are one of Angularâ€™s core features.

ğŸ”¹ Types of Directives in Angular
1. Component Directives

Technically, every component in Angular is a directive with a template.

Example:

@Component({
  selector: 'app-hello',
  template: `<h1>Hello Angular!</h1>`
})
export class HelloComponent {}


Usage:

<app-hello></app-hello>

2. Structural Directives

ğŸ‘‰ These change the DOM structure (add/remove elements).
They are prefixed with *.

*ngIf â†’ conditionally render elements.

<p *ngIf="isLoggedIn">Welcome, User!</p>


*ngFor â†’ loop through a list.

<ul>
  <li *ngFor="let item of items">{{ item }}</li>
</ul>


*ngSwitch â†’ multiple conditional rendering.

<div [ngSwitch]="role">
  <p *ngSwitchCase="'admin'">Admin Panel</p>
  <p *ngSwitchCase="'user'">User Dashboard</p>
  <p *ngSwitchDefault>Guest</p>
</div>

3. Attribute Directives

ğŸ‘‰ These change the look or behavior of an existing element/component.

Built-in Examples:

ngClass â†’ dynamically set CSS classes.

<p [ngClass]="{ active: isActive }">Text with class</p>


ngStyle â†’ dynamically set inline styles.

<p [ngStyle]="{ color: isActive ? 'green' : 'red' }">Styled text</p>


Custom Attribute Directive Example:

import { Directive, ElementRef, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  constructor(el: ElementRef, renderer: Renderer2) {
    renderer.setStyle(el.nativeElement, 'backgroundColor', 'yellow');
  }
}


Usage:

<p appHighlight>Highlighted Text</p>

âœ… Summary
Directive Type	Purpose	Example
Component	Defines a reusable UI block	<app-header></app-header>
Structural	Adds/removes DOM elements	*ngIf, *ngFor
Attribute	Changes look/behavior of elements	[ngClass], [ngStyle]

-----------------------------------------------------------------------------------

ğŸ”¹ What is <ng-template>?

Itâ€™s an Angular template element that isnâ€™t rendered directly in the DOM until Angular explicitly tells it to.

Angular uses it for structural directives like *ngIf, *ngFor, ngSwitch, etc.

It acts like a placeholder for content that can be shown conditionally or reused.

ğŸ”¹ Example 1: Basic ng-template with *ngIf
<h2 *ngIf="isLoggedIn; else guestBlock">
  Welcome User!
</h2>

<ng-template #guestBlock>
  <h2>Please log in</h2>
</ng-template>


ğŸ‘‰ Here:

If isLoggedIn is true â†’ "Welcome User!" is displayed.

If false â†’ Angular renders the <ng-template> content (guestBlock).

ğŸ”¹ Example 2: Multiple else if using ng-template
<h2 *ngIf="role === 'admin'; else managerBlock">Welcome Admin</h2>

<ng-template #managerBlock>
  <h2 *ngIf="role === 'manager'; else guestBlock">Welcome Manager</h2>
</ng-template>

<ng-template #guestBlock>
  <h2>Welcome Guest</h2>
</ng-template>

ğŸ”¹ Example 3: ngTemplateOutlet (Reusing Templates)
<ng-template #messageTemplate let-name="userName">
  <p>Hello, {{ name }}!</p>
</ng-template>

<!-- Reuse the same template -->
<ng-container *ngTemplateOutlet="messageTemplate; context:{ userName: 'Alice' }"></ng-container>
<ng-container *ngTemplateOutlet="messageTemplate; context:{ userName: 'Bob' }"></ng-container>


ğŸ‘‰ Output:

Hello, Alice!
Hello, Bob!

ğŸ”¹ Why ng-template?

Before Angular v17â€™s new @if/@for syntax, it was the only way to handle else conditions and template reuse.

Even now, itâ€™s still useful when:

You want reusable UI blocks.

You want to pass template references into child components.


---------------------------------------------------------------------------------------------------------

1. Structural Directives

Definition: They change the structure of the DOM (add, remove, or replace elements).

Identifiable by: They usually start with a * in templates.

Examples:

*ngIf â†’ adds/removes element based on condition

*ngFor â†’ repeats an element for each item in a list

*ngSwitchCase â†’ conditionally displays templates

ğŸ‘‰ They manipulate the DOM layout itself.

Example:

<div *ngIf="isLoggedIn">Welcome, User!</div>


If isLoggedIn = false, this <div> wonâ€™t even exist in the DOM.

2. Attribute Directives

Definition: They change the appearance or behavior of an existing element, component, or directive without altering the DOM structure.

Examples:

ngClass â†’ add/remove CSS classes

ngStyle â†’ apply inline styles dynamically

Custom attribute directives (like [appHighlight])

ğŸ‘‰ They modify the look/behavior of an element.

Example:

<p [ngStyle]="{color: isError ? 'red' : 'green'}">
  Status Message
</p>


Here <p> always exists, only its style changes.

ğŸ”‘ Key Difference
Feature	Structural Directive ğŸ—	Attribute Directive ğŸ¨
Effect	Alters DOM structure (add/remove elements)	Alters appearance/behavior of element
Template Syntax	Uses * (e.g., *ngIf)	Uses [] or normal attribute syntax
Examples	*ngIf, *ngFor, *ngSwitch	ngClass, ngStyle, custom highlight

ğŸ‘‰ So, think like this:

Structural = Building blocks of DOM (existence of elements)

Attribute = Decorating existing DOM elements
------------------------------------------------------------------------------------------

1. Parent â†’ Child Communication

The Parent passes data to the Child using @Input().

Example:

Parent component template (app.component.html):

<app-child [childData]="parentMessage"></app-child>


Parent component class (app.component.ts):

parentMessage = "Hello from Parent!";


Child component (child.component.ts):

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ childData }}</p>`
})
export class ChildComponent {
  @Input() childData!: string;
}


âœ” Here, the parent passes parentMessage to the child.

2. Child â†’ Parent Communication

The Child sends data back to the Parent using @Output() + EventEmitter.

Example:

Child component (child.component.ts):

import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<button (click)="sendData()">Send to Parent</button>`
})
export class ChildComponent {
  @Output() childEvent = new EventEmitter<string>();

  sendData() {
    this.childEvent.emit("Hello Parent! from Child");
  }
}


Parent template (app.component.html):

<app-child (childEvent)="receiveData($event)"></app-child>
<p>{{ messageFromChild }}</p>


Parent class (app.component.ts):

messageFromChild = "";

receiveData(data: string) {
  this.messageFromChild = data;
}


âœ” The child emits data, and the parent catches it.

3. Sibling â†’ Sibling Communication

Siblings cannot directly communicate (since they are at the same level).
We use a shared service with RxJS Subject/BehaviorSubject to share data.

Example:

Shared service (data.service.ts):

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class DataService {
  private messageSource = new BehaviorSubject<string>("Default Message");
  currentMessage = this.messageSource.asObservable();

  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}


Sibling 1 (sibling1.component.ts):

import { Component } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-sibling1',
  template: `<button (click)="newMessage()">Send to Sibling2</button>`
})
export class Sibling1Component {
  constructor(private dataService: DataService) {}

  newMessage() {
    this.dataService.changeMessage("Hello from Sibling 1!");
  }
}


Sibling 2 (sibling2.component.ts):

import { Component, OnInit } from '@angular/core';
import { DataService } from '../data.service';

@Component({
  selector: 'app-sibling2',
  template: `<p>{{message}}</p>`
})
export class Sibling2Component implements OnInit {
  message!: string;

  constructor(private dataService: DataService) {}

  ngOnInit() {
    this.dataService.currentMessage.subscribe(msg => this.message = msg);
  }
}


âœ” Now, Sibling1 â†’ Service â†’ Sibling2 communication works.

ğŸ”‘ Summary

Parent â†’ Child â†’ @Input()

Child â†’ Parent â†’ @Output() + EventEmitter

Sibling â†’ Sibling â†’ Shared service with RxJS
